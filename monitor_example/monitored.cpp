/// @file fuzz.cpp
/// @brief Generated by DEXTOOL_VERSION: v0.8.3-502-ga64b2cf
/// DO NOT EDIT THIS FILE, it will be overwritten on update.
#include "monitored.hpp"

namespace Ops_Mode {
    namespace Ops_State{
        namespace Requirer {
	    class I_Ops_State_Impl : public I_Ops_State {
	    private:
		Ops_Mode::Ops_State::Ops_State_Type ops_state;
		RandomGenerator* randomGenerator;
		std::string name;
	    public:
		I_Ops_State_Impl(std::string n) {
                    randomGenerator = &TestingEnvironment::createRandomGenerator();
		    
		    name = n;
                }
		~I_Ops_State_Impl() {
                }

		void Regenerate() {
		    ops_state.Ops_State = static_cast<Ops_Mode::Ops_Mode_Type::Enum>(randomGenerator->generate(0, 2));
		    ops_state.Ops_Quality = static_cast<Ops_Mode::Ops_Mode_Quality_Type::Enum>(randomGenerator->generate(0, 2));
		}

		//Must be implemented
		void Regenerate(const std::map<std::string, std::vector<std::vector<int>>> &vars, const int64_t &curr_cycles) {
		    ops_state.Ops_State = static_cast<Ops_Mode::Ops_Mode_Type::Enum>(randomGenerator->generate(vars, "ops_state.Ops_State", 0, 2, curr_cycles));
		    ops_state.Ops_Quality = static_cast<Ops_Mode::Ops_Mode_Quality_Type::Enum>(randomGenerator->generate(vars, "ops_state.Ops_Quality", 0, 2, curr_cycles));
		}

		const Ops_Mode::Ops_State::Ops_State_Type& Get_Ops_State(void) const {
		    return ops_state;
		}
		const Ops_Mode::Ops_Mode_Type::Enum Get_Ops_State_Ops_State(void) const {
		    return ops_state.Ops_State;
		}
		void Ops_State_Ops_State_Changed(const Ops_Mode::Ops_Mode_Type::Enum New_Val) {
		    ops_state.Ops_State = New_Val;
		}
		const Ops_Mode::Ops_Mode_Quality_Type::Enum Get_Ops_State_Ops_State_Quality(void) const {
		    return ops_state.Ops_Quality;
		}
		void Ops_State_Ops_State_Quality_Changed(const Ops_Mode::Ops_Mode_Quality_Type::Enum New_Val) {
		    ops_state.Ops_Quality = New_Val;
		}

		const std::string getNamespace() {
                    return "Ops_Mode::Ops_State::Requirer";
                }

		const std::string getName() {
                    return name;
                }
	    };
	    I_Ops_State::I_Ops_State() {
            }
            I_Ops_State::~I_Ops_State() {
            }
	    class I_Ops_State_Requirer_Impl : public I_Ops_State_Requirer {
            private:
                I_Ops_State* port;
            public:
		I_Ops_State_Requirer_Impl() {
                }
		I_Ops_State_Requirer_Impl(I_Ops_State* p) {
                    port = p;
                }
		Ops_Mode::Ops_State::Requirer::I_Ops_State & Get_Port() {
                    return *port;
                }
            };
            I_Ops_State_Requirer::I_Ops_State_Requirer() {
            }
            I_Ops_State_Requirer::~I_Ops_State_Requirer() {
            }
            Ops_Mode::Ops_State::Requirer::I_Ops_State_Requirer & Create_Instance(const std::basic_string<char> & name) {
                return PortEnvironment::createPort<I_Ops_State_Requirer_Impl, I_Ops_State, I_Ops_State_Impl, const std::basic_string<char> >(name, name);
            }
        } //NS:Requirer
    } //NS:Bar
} //NS:Foo

namespace Ops_Mode {
    namespace Ops_State{
        namespace Provider {
	    class I_Ops_State_Impl : public I_Ops_State {
	    private:
		Ops_Mode::Ops_State::Ops_State_Type ops_state;
		RandomGenerator* randomGenerator;
		std::string name;
	    public:
		I_Ops_State_Impl(std::string n) {
                    randomGenerator = &TestingEnvironment::createRandomGenerator();
		    
		    name = n;
                }
		~I_Ops_State_Impl() {
                }

		void Regenerate() {
		    ops_state.Ops_State = static_cast<Ops_Mode::Ops_Mode_Type::Enum>(randomGenerator->generate(0, 2));
		    ops_state.Ops_Quality = static_cast<Ops_Mode::Ops_Mode_Quality_Type::Enum>(randomGenerator->generate(0, 2));
		}

		//Must be implemented
		void Regenerate(const std::map<std::string, std::vector<std::vector<int>>> &vars, const int64_t &curr_cycles) {
		    ops_state.Ops_State = static_cast<Ops_Mode::Ops_Mode_Type::Enum>(randomGenerator->generate(vars, "ops_state.Ops_State", 0, 2, curr_cycles));
		    ops_state.Ops_Quality = static_cast<Ops_Mode::Ops_Mode_Quality_Type::Enum>(randomGenerator->generate(vars, "ops_state.Ops_Quality", 0, 2, curr_cycles));
		}

		const Ops_Mode::Ops_State::Ops_State_Type& Get_Ops_State(void) const {
		    return ops_state;
		}
		void Put_Ops_State(const Ops_Mode::Ops_Mode_Type::Enum Ops_State, const Ops_Mode::Ops_Mode_Quality_Type::Enum Ops_State_qual) {
		    ops_state.Ops_State = Ops_State;
		    ops_state.Ops_Quality = Ops_State_qual;
		}

		const bool Will_data_on_Ops_State_be_sent() const {
		    return randomGenerator->generate(0, 1);
		}

		const std::string getNamespace() {
                    return "Ops_Mode::Ops_State::Provider";
                }

		const std::string getName() {
                    return name;
                }
	    };
	    I_Ops_State::I_Ops_State() {
            }
            I_Ops_State::~I_Ops_State() {
            }
	    class I_Ops_State_Provider_Impl : public I_Ops_State_Provider {
            private:
                I_Ops_State* port;
            public:
		I_Ops_State_Provider_Impl() {
                }
		I_Ops_State_Provider_Impl(I_Ops_State* p) {
                    port = p;
                }
		Ops_Mode::Ops_State::Provider::I_Ops_State & Get_Port() {
                    return *port;
                }

            };
            I_Ops_State_Provider::I_Ops_State_Provider() {
            }
            I_Ops_State_Provider::~I_Ops_State_Provider() {
            }
            Ops_Mode::Ops_State::Provider::I_Ops_State_Provider & Create_Instance(const std::basic_string<char> & name) {
                return PortEnvironment::createPort<I_Ops_State_Provider_Impl, I_Ops_State, I_Ops_State_Impl, const std::basic_string<char> >(name, name);
            }
        } //NS:Provider
    } //NS:Bar
} //NS:Foo
