/// @file fuzz.cpp
/// @brief Generated by DEXTOOL_VERSION: v0.8.3-502-ga64b2cf
/// DO NOT EDIT THIS FILE, it will be overwritten on update.
#include "event_status.hpp"

struct Event {
    unsigned Event_number;
    bool Stranded;
};

namespace Foo {
    namespace Event_Status {
        namespace Provider {
	    class I_Event_Status_Impl : public I_Event_Status {
	    private:
		std::vector<std::string> clients;
		RandomGenerator* randomGenerator;
		Event event;
		std::string name;
	    public:
		//std::string name;
		I_Event_Status_Impl(std::string n) {
                    randomGenerator = &TestingEnvironment::createRandomGenerator();
		    randomGenerator->generateClients(clients, 1024);
		    name = n;
                }
		~I_Event_Status_Impl() {
                }

		void Regenerate() {
		    //Do we want to randomize new clients each cycle?
		    //randomGenerator->generateClients(clients, 1024);
		    Event_Event(randomGenerator->generate(1, 999),
				randomGenerator->generate(0, 1));
		}

		//Must be implemented
		void Regenerate(const std::map<std::string, std::vector<std::vector<int>>> &vars, const int64_t &curr_cycles) {
		    //Do we want to randomize new clients each cycle?
		    //randomGenerator->generateClients(clients, 1024);
		    Event_Event(randomGenerator->generate(vars, "event.Event_number", 1, 999, curr_cycles), 
				randomGenerator->generate(vars, "event.Stranded", 0, 1, curr_cycles));
		}

		bool Is_Client_Connected(std::string client_name) const {
		    for (auto n : clients) {
			if (n == client_name) {
			    return true;
			} 
		    }
		    return false;
		}

		unsigned Get_Client_Id(std::string client_name) const {
		    unsigned ret = 0;
		    for (auto n : clients) {
			if (n == client_name) {
			    return ret;
			}
			ret++;
		    }
		    return -1;
		} //coherent

		const std::string Get_Client_Name(const unsigned client_id) const {
		    if (clients.size() != 0 && client_id < clients.size()
			&& client_id > 0) {
			return clients.at(client_id);
		    }
		    else {
			return "";
		    }
		} //coherent

		unsigned Get_Number_Of_Clients() const {
		    return clients.size();
		} //coherent

		void Event_Event(const unsigned event_id, const bool stranded) {
		    event.Event_number = event_id;
		    event.Stranded = stranded;
		}

		unsigned Get_Event__Bandwidth(const unsigned int client_id) const {
		    return 1;
		} //hardcoded

		const std::string getNamespace() {
                    return "Foo::Event_Status::Provider";
                }

		const std::string getName() {
                    return name;
                }

		std::vector<std::string> &getClients() {
                    return clients;
                }
	    };
	    I_Event_Status::I_Event_Status() {
            }
            I_Event_Status::~I_Event_Status() {
            }
	    class I_Event_Status_Provider_Impl : public I_Event_Status_Provider {
            private:
                I_Event_Status* port;
            public:
		I_Event_Status_Provider_Impl() {
                }
		I_Event_Status_Provider_Impl(I_Event_Status* p) {
                    port = p;
                }
                Foo::Event_Status::Provider::I_Event_Status_Impl & Get_Port() {
                    return *static_cast<I_Event_Status_Impl*>(port);
                }

		void Connect_Port(Foo::Event_Status::Provider::I_Event_Status& Other_End) {
		    std::string Other_End_Name = (*static_cast<I_Event_Status_Impl*>(&Other_End)).getName();
		    if (!Get_Port().Is_Client_Connected(Other_End_Name)) {
			Get_Port().getClients().push_back(Other_End_Name);
		    }
		}
            };
            I_Event_Status_Provider::I_Event_Status_Provider() {
            }
            I_Event_Status_Provider::~I_Event_Status_Provider() {
            }
            Foo::Event_Status::Provider::I_Event_Status_Provider & Create_Instance(const std::basic_string<char> & name) {
                return PortEnvironment::createPort<I_Event_Status_Provider_Impl, I_Event_Status, I_Event_Status_Impl, const std::basic_string<char> >(name, name);
            }
        } //NS:Requirer
    } //NS:Bar
} //NS:Foo
