/// @file fuzz.cpp
/// @brief Generated by DEXTOOL_VERSION: v0.8.3-502-ga64b2cf
/// DO NOT EDIT THIS FILE, it will be overwritten on update.
#include "event_status.hpp"

namespace Foo {
    namespace Event_Status {
        namespace Provider {
	    class I_Event_Status_Impl : public I_Event_Status {
	    private:
		std::vector<std::string> clients;
		RandomGenerator* randomGenerator;
	    public:
		I_Event_Status_Impl() {
                    randomGenerator = &TestingEnvironment::createRandomGenerator();
		    randomGenerator->generateClients(clients, 1024);
                }
		~I_Event_Status_Impl() {
                }

		void Regenerate() {
		    randomGenerator->generate();
		}

		//Must be implemented
		void Regenerate(const std::map<std::string, std::vector<std::vector<int>>> &vars, const int &curr_cycles) {
		    randomGenerator->generate(vars, 0, 100);
		}

		bool Is_Client_Connected(std::string client_name) const {
		    return randomGenerator->generate(0, 1);
		} //random

		unsigned Get_Client_Id(std::string client_name) const {
		    unsigned ret = 0;
		    for (auto n : clients) {
			if (n == client_name) {
			    return ret;
			}
			ret++;
		    }
		    return -1;
		} //coherent

		const std::string Get_Client_Name(const unsigned client_id) const {
		    if (clients.size() != 0 && client_id < clients.size()
			&& client_id > 0) {
			return clients.at(client_id);
		    }
		    else {
			return "";
		    }
		} //coherent

		unsigned Get_Number_Of_Clients() const {
		    return clients.size();
		} //coherent

		unsigned Get_Event__Bandwidth(const unsigned int client_id) const {
		    return 1;
		} //hardcoded

		std::string getNamespace() {
                    return "Foo::Event_Status::Provider";
                }
	    };
	    I_Event_Status::I_Event_Status() {
            }
            I_Event_Status::~I_Event_Status() {
            }
	    class I_Event_Status_Provider_Impl : public I_Event_Status_Provider {
            private:
                I_Event_Status* port;
            public:
		I_Event_Status_Provider_Impl() {
                }
		I_Event_Status_Provider_Impl(I_Event_Status* p) {
                    port = p;
                }
                Foo::Event_Status::Provider::I_Event_Status & Get_Port() {
                    return *port;
                }
            };
            I_Event_Status_Provider::I_Event_Status_Provider() {
            }
            I_Event_Status_Provider::~I_Event_Status_Provider() {
            }
            Foo::Event_Status::Provider::I_Event_Status_Provider & Create_Instance(const std::basic_string<char> & name) {
                return PortEnvironment::createPort<I_Event_Status_Provider_Impl, I_Event_Status, I_Event_Status_Impl, const std::basic_string<char> >(name, name);
            }
        } //NS:Requirer
    } //NS:Bar
} //NS:Foo
